**目录**
[toc]

标题：C学习：指针初始化的误区

> 你以为你理解指针了？
> 不，你并没有……


**现象**：有段关于指针的代码，遇到这种情况，编译通过，运行到指针语句就报错`Segmentation fault`.

**代码如下：**

```c
short *seed = 0;
*seed += 1024;
```

- 预期：目的是想声明一个指针，并赋值0；下一步对该值加1024.
- 实际：定义一个指针变量，并对其地址赋值为0。**第一行代码**等价于： `short *seed; seed = 0;`

所以，第一行是有问题的，第二行ok。运行会报错`Segmentation fault`。

**修改后：**

```c
short *seed;
*seed = 0;
*seed += 1024;
```

- 预期：在c文件中定义一个指针变量；并向该指针变量指向的值赋初值0；
- 实际：定义一个指针变量，但该变量没有初始化，`seed`的地址是个野指针，不知道地址是指向哪儿。

所以给野指针随机指向的地址赋值，会报错`Segmentation fault`。可以看出语句 `short *seed`，只会初始化指针变量，但初始值是随机的，需要被显性定义才能解引用`*seed`。

**再次修改：**

```c
short seed = 0;
short *pSeed = &seed;
*pSeed += 1024;
```

ok，变量`seed `已定义并分配内存，有实际内存地址，故可以把该地址赋给`pSeed`，让它引用。

**通过此次debug，可以加深对C语言指针的理解。**