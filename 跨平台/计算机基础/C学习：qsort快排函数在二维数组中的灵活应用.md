**目录**
[toc]


> 作者：来知晓
> 公众号：来知晓
> 简介：哈工大硕士，华为算法工程师，专注分享读书、职场、技术及自我提升等内容

标题：C学习：qsort快排函数在二维数组中的灵活应用

## 引入
----
在上一篇文章《[qsort快排小结](https://blog.csdn.net/qq_17256689/article/details/108567201)》中初步实现了在二维数组中按某列元素的大小来升序排列整个数组，这篇文章根据需求灵活应用qsort快排函数，辅以实例，增进理解。

下面**主要围绕**以下几个问题讨论：
 - **如何按某列的元素大小来排各行的序**？即横向排序各行。
 - **如何按某行的元素大小来排各列的序**？即竖向排序各列。
 - **是否可以仅对二维数组某行或某列来进行排序**？


## 应用实现
----
完整测试代码可以先看下最后一节，有个整体印象。然后再回过头看具体应用实现的说明。

**前提条件：**
 - 设b_arr为2位数组，仅3列；
 - cmp2为比较函数，比较二维数组某两个元素的大小；

### 问题1:按某列大小来排各行的序
**思路：**
按某列的元素大小来排各行的序，内部连续存储，qsort实现只是跟据某列元素比较结果，将改行元素从行首开始批量挪固定长度的数据交换。
利用快排的入参中，修改比较函数，由于二维数组存储是连续的，所以可以仅比较某列的元素来实现。

**问题1中**，qsort函数一直为：`qsort(b_arr, 3, 3* sizeof(int), cmp2);`
**参数解释**：
 - b_arr为二维数组首地址， 
 - 3表示比较元素的个数， 
 - 3 * sizeof(int)表示整个元素相关的拷贝空间大小，
   cmp2为比较函数函数指针。

比如我要按第1列的元素大小排序，将各行调整为1列的大小升序排列，那需要整体移动一行的数据，大小即`3 * sizeof(int)`。

修改：
```c
cmp2中， ((int *)a)[0] - ((int *)b)[0]  
//a为某一行的首地址，向后偏移0位，用[0]还有解引用的功能，即取a[i][0]
```
按第1列排序效果：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20201006112654858.png#pic_left)
修改：
```c
cmp2中， ((int *)a)[1] - ((int *)b)[1]
//a为某一行的首地址，向后偏移1位，即取a[i][1]
```

按第2列排序效果：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20201006112201265.png#pic_left)
修改：
```c
cmp2中， ((int *)a)[2] - ((int *)b)[2]
```
按第3列排序效果：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20201006112201270.png#pic_left)
### 问题2:按某行大小来排各列的序
**思路**：如果需要按某行的元素来排各列的序，因为在内部存储时不是连续的，最直接的方式是将数组行列互换然后再排序，之后再转回来。
核心实现还是用的问题1的方法，故这里不赘述。
 

### 问题3:仅对二维数组某行排序
**思路**：仅针对二维数组的某行进行升序排序，修改cmp内的比较函数为传入的第一个地址比值不往后偏移，qosrt传参的首地址为某行首地址，即可。

而仅对某列来进行排序，由于存储不连续，qsort只能从首地址开始，按第三个入参`n * sizeof(int)`这样的大小往后移比值的元素地址，中间连续部分关联空间则批量拷贝。所以也只能先转成行后，排完某行，在行列转换回来，更直接便捷。

仅对第1行排序，修改如下：
```c
cmp2中，   ((int *)a)[0] - ((int *)b)[0]  //直接比较当前传入的二维数组所对应的值
qsort中，  qsort(b_arr, 3, 1 * sizeof(int), cmp2);  
等价于：   qsort(&(b_arr[0][0]), 3, 1 * sizeof(int), cmp2);
//传入第1行第1列首地址， 只比较3个元素，元素相关空间只有1int大小即4byte。
```
仅对第1行排序效果：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20201006112201226.png#pic_left)
仅对第2行排序，修改如下：
```c
cmp2中，   ((int *)a)[0] - ((int *)b)[0]
qsort中，  qsort(&b_arr[1][0], 3, 1 * sizeof(int), cmp2);
//传入第2行第1列首地址， 只比较3个元素，元素相关空间只有1int大小即4byte。所以只比较第2行开始的3个int数据。
```
仅对第2行排序效果：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20201006112201267.png#pic_left)
修改：
```c
cmp2中，   ((int *)a)[0] - ((int *)b)[0]
qsort中，  qsort(&b_arr[2][0], 3, 1 * sizeof(int), cmp2);
```

仅对第3行排序效果：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20201006112823526.png#pic_left)

## 完整测试代码
----
要根据需要适当修改`i,j和b_arr`的大小。

```c
#include <stdio.h>
#include <stdlib.h>
int b_arr[][3] = { {3, 2, 5},
                   {1, 1, 8},
                   {6, 2, 9},
                   {9, 2, 4} };
                   
int cmp2(const void* a, const void* b) // 2D Matrix
{
    return ((int *)a)[2] - ((int *)b)[2];
}

int main()
{
    printf("Hello world!\n");
    int i, j;
    for (i = 0; i < 4; i++) {
        for (j = 0; j < 3; j++) {
            printf("%d ", b_arr[i][j]);
        }
        printf("\n");
    }

    qsort(b_arr, 3, 3 * sizeof(int), cmp2);
    printf("After sorted: \n");
    for (i = 0; i < 4; i++) {
        for (j = 0; j < 3; j++) {
            printf("%d ", b_arr[i][j]);
        }
        printf("\n");
    }

    return 0;
}
```








